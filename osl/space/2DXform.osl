/*
 *  Copyright 2023 Laika, LLC. Authored by Mitch Prater.
 *
 *  Licensed under the Apache License Version 2.0 http://apache.org/licenses/LICENSE-2.0,
 *  or the MIT license http://opensource.org/licenses/MIT, at your option.
 *
 *  This program may not be copied, modified, or distributed except according to those terms.
 */
shader space_2DXform
[[
    int rfm_nodeid = 1234271,
    string rfm_classification = "rendernode/RenderMan/pattern/Laika"
]]
(
    string Notes = ""
    [[
        int connectable = 0,
        string help =
            "Transforms the connected Input point. "
    ]],

    point In = point(0)
    [[
        string readOnly = "True",
        string help =
            "The point to transform. "
    ]],

    float InSize = 1.0
    [[
        string label = "In Size",
        string readOnly = "True",
        string help =
            "The <b>Size</b> of the connected <b>In</b> point's variations. "
    ]],

    float Size = 1.0
    [[
        string label = "Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b>. "
    ]],

    float SizeMultiplier = 1.0
    [[
        string label = "Size Multiplier",
        string widget = "mapper",
        string options =
            "x0.01:0.01"
            "|x0.1:0.1"
            "|x1:1.0"
            "|x10:10.0"
            "|x100:100.0",
        string help =
            "Multiplies the <b>Size</b> by this constant, changing its effective range. "
    ]],

    float XSize = 1.0
    [[
        string label = "X (U) Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b> "
            "in the <b>X</b> (a.k.a. <i>s</i> or <i>U</i>) direction. "
    ]],

    float YSize = 1.0
    [[
        string label = "Y (V) Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b> "
            "in the <b>Y</b> (a.k.a. <i>t</i> or <i>V</i>) direction. "
    ]],

    float Rotation = 0.0
    [[
        string label = "Rotation",
        int slider = 1, float slidermin = -180.0, float slidermax = 180.0,
        string help =
            "Rotates <b>Y</b> (a.k.a. <i>t</i> or <i>V</i>) <i>into</i> "
            "<b>X</b> (a.k.a. <i>s</i> or <i>U</i>) by this many degrees. "
            "<p>"
            "Counterintuitively, this moves a pattern generated by this space in the opposite direction. "
            "</p>"
    ]],

    float XOffset = 0.0
    [[
        string label = "X (U) Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the Output "
            "in the <b>&ndash;X</b> (a.k.a. <i>s</i> or <i>U</i>) direction. "
            "<p>"
            "Counterintuitively, this moves a pattern generated by this space "
            "in the opposite direction. "
            "</p>"
    ]],

    float YOffset = 0.0
    [[
        string label = "Y (V) Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the Output "
            "in the <b>&ndash;Y</b> (a.k.a. <i>t</i> or <i>V</i>) direction. "
            "<p>"
            "Counterintuitively, this moves a pattern generated by this space "
            "in the opposite direction. "
            "</p>"
    ]],

    int UniqueOffset = 0
    [[
        int connectable = 0,
        string label = "Unique Offset",
        int slider = 1, int slidermin = 0, int slidermax = 10,
        string help =
            "When <i>non-zero</i>, each object will produce a unique offset "
            "based on the object <code>id</code> that is then applied to the result. "
            "In this way, the result will be offset differently for each object. "
            "Larger values of <b>Unique Offset</b> produce larger random offsets. "
    ]],

    output point Out = point(0),
    output float OutSize = 1.0,

    // Will read the 'st' primvar, or sets (s,t) = (u,v) if there is none.
    float  s = 0.0 [[ int lockgeom = 0, int connectable = 0, string widget = "null" ]],
    float  t = 0.0 [[ int lockgeom = 0, int connectable = 0, string widget = "null" ]]
)
{
    if( isconnected( In ))
    {
        Out = In;
    }
    else
    {
        // Get st space: the Texture UV's.
        Out = point( s, t, 0 );
    }

    float  size = Size * SizeMultiplier;
    float  xSize = max( 1.0e-6, size * XSize );
    float  ySize = max( 1.0e-6, size * YSize );
    float  rotation = radians( Rotation );

    // Size.
    Out /= point( xSize, ySize, 1.0 );
    OutSize = sqrt( xSize*ySize ) * InSize;

    // Rotate.
    float  sine, cosine;
    sincos( rotation, sine, cosine );

    Out = point(
            Out.x*cosine + Out.y*sine,
            Out.y*cosine - Out.x*sine,
            Out.z
            );

    // Offset.
    Out -= point( XOffset, YOffset, 0.0 );

    // Compute an object-based offset as needed.
    if( 0 != UniqueOffset )
    {
        int  id = 0;
        getattribute( "builtin", "id", id ); // bottom 32 bits of id.
        int  id2 = 0;
        getattribute( "builtin", "id2", id2 ); // top 32 bits of id. Only used by katana.

        Out += UniqueOffset*vector( hashnoise( id, id2 ));
    }
}
