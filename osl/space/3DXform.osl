/*
 *  Copyright 2023 Laika, LLC. Authored by Mitch Prater.
 *
 *  Licensed under the Apache License Version 2.0 http://apache.org/licenses/LICENSE-2.0,
 *  or the MIT license http://opensource.org/licenses/MIT, at your option.
 *
 *  This program may not be copied, modified, or distributed except according to those terms.
 */
shader space_3DXform
[[
    int rfm_nodeid = 1234273,
    string rfm_classification = "rendernode/RenderMan/pattern/Laika"
]]
(
    string Notes = ""
    [[
        int connectable = 0,
        string help =
            "Transforms the connected Input point. "
    ]],

    point In = point(0)
    [[
        string readOnly = "True",
        string help =
            "The point to transform. "
    ]],

    float InSize = 1.0
    [[
        string label = "In Size",
        string readOnly = "True",
        string help =
            "The <b>Size</b> of the connected <b>In</b> point's variations. "
    ]],

    float Size = 1.0
    [[
        string label = "Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b>. "
    ]],

    float SizeMultiplier = 1.0
    [[
        string label = "Size Multiplier",
        string widget = "mapper",
        string options =
            "x0.01:0.01"
            "|x0.1:0.1"
            "|x1:1.0"
            "|x10:10.0"
            "|x100:100.0",
        string help =
            "Multiplies the <b>Size</b> by this constant, changing its effective range. "
    ]],

    float XSize = 1.0
    [[
        string label = "X Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b> "
            "in the <b>X</b> (a.k.a. <i>s</i> or <i>U</i>) direction. "
    ]],

    float YSize = 1.0
    [[
        string label = "Y Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b> "
            "in the <b>Y</b> (a.k.a. <i>t</i> or <i>V</i>) direction. "
    ]],

    float ZSize = 1.0
    [[
        string label = "Z Size",
        int slider = 1, float slidermin = 0.1, float slidermax = 10.0, float slidercenter = 1.0,
        string help =
            "Adjusts the Output's <b>Size</b> "
            "in the <b>Z</b> direction. "
    ]],

    int RotationType = 1
    [[
        string label = "Rotation Type",
        int connectable = 0,
        string widget = "mapper",
        string options = "None:0|Axes:1|Vector:2",
        string help =
            "Rotate the Input about its X, Y, and Z <i>Axes</i>, "
            "or a <i>Rotation Vector</i>. "
    ]],

    float XRotation = 0.0
    [[
        string conditionalVisPath = "../RotationType",
        string conditionalVisOp = "equalTo",
        string conditionalVisValue = "1",

        string label = "X Rotation",
        int slider = 1, float slidermin = -180.0, float slidermax = 180.0,
        string help =
            "Rotates <b>Z</b> <i>into</i> <b>Y</b> by this many degrees. "
            "<br/><br/>"
            "Counterintuitively, this moves a pattern generated by this space in the opposite direction. "
    ]],

    float YRotation = 0.0
    [[
        string conditionalVisPath = "../RotationType",
        string conditionalVisOp = "equalTo",
        string conditionalVisValue = "1",

        string label = "Y Rotation",
        int slider = 1, float slidermin = -180.0, float slidermax = 180.0,
        string help =
            "Rotates <b>X</b> <i>into</i> <b>Z</b> by this many degrees. "
            "<br/><br/>"
            "Counterintuitively, this moves a pattern generated by this space in the opposite direction. "
    ]],

    float ZRotation = 0.0
    [[
        string conditionalVisPath = "../RotationType",
        string conditionalVisOp = "equalTo",
        string conditionalVisValue = "1",

        string label = "Z Rotation",
        int slider = 1, float slidermin = -180.0, float slidermax = 180.0,
        string help =
            "Rotates <b>Y</b> (a.k.a. <i>t</i> or <i>V</i>) <i>into</i> "
            "<b>X</b> (a.k.a. <i>s</i> or <i>U</i>) by this many degrees. "
            "<br/><br/>"
            "Counterintuitively, this moves a pattern generated by this space in the opposite direction. "
    ]],

    vector RotationVector = vector(0.0)
    [[
        string conditionalVisPath = "../RotationType",
        string conditionalVisOp = "equalTo",
        string conditionalVisValue = "2",

        string label = "Rotation Vector",
        string help =
            "This <b>Rotation Vector</b> defines the axis about which to rotate the point. "
    ]],

    float VectorRotation = 0.0
    [[
        string conditionalVisPath = "../RotationType",
        string conditionalVisOp = "equalTo",
        string conditionalVisValue = "2",

        string label = "Vector Rotation",
        int slider = 1, float slidermin = -180.0, float slidermax = 180.0,
        string help =
            "Rotates the Output about the <b>Rotation Vector</b> by this many degrees. "
            "<br/><br/> "
            "Counterintuitively, this moves a pattern generated by this space "
            "in the opposite direction. "
    ]],

    float XOffset = 0.0
    [[
        string label = "X Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the Output "
            "in the <b>&ndash;X</b> (a.k.a. <i>s</i> or <i>U</i>) direction. "
            "<br/><br/> "
            "Counterintuitively, this moves a pattern generated by this space "
            "in the opposite direction. "
    ]],

    float YOffset = 0.0
    [[
        string label = "Y Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the Output "
            "in the <b>&ndash;Y</b> (a.k.a. <i>t</i> or <i>V</i>) direction. "
            "<br/><br/> "
            "Counterintuitively, this moves a pattern generated by this space "
            "in the opposite direction. "
    ]],

    float ZOffset = 0.0
    [[
        string label = "Z Offset",
        int slider = 1, float slidermin = -5.0, float slidermax = 5.0,
        string help =
            "<b>Offset</b> the Output "
            "in the <b>&ndash;Z</b> direction. "
            "<br/><br/> "
            "Counterintuitively, this moves a pattern generated by this space "
            "in the opposite direction. "
    ]],

    int UniqueOffset = 0
    [[
        int connectable = 0,
        string label = "Unique Offset",
        int slider = 1, int slidermin = 0, int slidermax = 10,
        string help =
            "When <i>non-zero</i>, each object will produce a unique offset "
            "based on the object <tt>id</tt> that is then applied to the result. "
            "In this way, the result will be offset differently for each object. "
            "Larger values of <b>Unique Offset</b> produce larger random offsets. "
    ]],

    output point Out = point(0),
    output float OutSize = 1.0
)
{
    // Referencing P is required for any down-stream auto-differentiation.
    Out = P;

    // Use In if connected.
    if( isconnected( In )) Out = In;
    else
    {
        // Check for __Pref.
        if( !getattribute( "primvar", "__Pref", Out ))
        {
            // Use un-displaced P.
            getattribute( "builtin", "Po", Out );
        }

        // Restore the original primvar values,
        // or start with "object" space.
        Out = transform( "common", "object", Out );

        // Apply world scale.
        matrix  object_to_world;
        if( getmatrix( "object", "world", object_to_world ))
        {
            Out *= pow( abs( determinant( object_to_world )), 0.33333333 );
        }
    }

    float  size = Size * SizeMultiplier;
    float  xSize = max( 1.0e-6, size * XSize );
    float  ySize = max( 1.0e-6, size * YSize );
    float  zSize = max( 1.0e-6, size * ZSize );
    float  xRotation = radians( XRotation );
    float  yRotation = radians( YRotation );
    float  zRotation = radians( ZRotation );
    float  vRotation = radians( VectorRotation );

    // Size.
    Out /= point( xSize, ySize, zSize );
    OutSize = pow( xSize*ySize*zSize, (1.0/3.0) ) * InSize;

    // Rotate.
    if( 1 == RotationType )
    {
        float  sine, cosine;

        sincos( xRotation, sine, cosine );
        Out = point(
                Out.x,
                Out.y*cosine + Out.z*sine,
                Out.z*cosine - Out.y*sine
                );

        sincos( yRotation, sine, cosine );
        Out = point(
                Out.x*cosine - Out.z*sine,
                Out.y,
                Out.z*cosine + Out.x*sine
                );

        sincos( zRotation, sine, cosine );
        Out = point(
                Out.x*cosine + Out.y*sine,
                Out.y*cosine - Out.x*sine,
                Out.z
                );
    }

    else if( 2 == RotationType )
    {
        vector  rotationV = RotationVector;
        if( !isconnected( RotationVector ) && vector(0.0) == RotationVector )
        {
            rotationV = -transform( "camera", "object", point(0.0) );
        }
        Out = rotate( Out, vRotation, point(0.0), rotationV );
    }

    // Offset.
    Out -= point( XOffset, YOffset, ZOffset );

    // Compute an object-based offset as needed.
    if( 0 != UniqueOffset )
    {
        int  id = 0;
        getattribute( "builtin", "id", id ); // bottom 32 bits of id.
        int  id2 = 0;
        getattribute( "builtin", "id2", id2 ); // top 32 bits of id. Only used by katana.

        Out += UniqueOffset*vector( hashnoise( id, id2 ));
    }
}
